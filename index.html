<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Структурное программирование: Никлаус Вирт</title>
    <link rel="stylesheet" href="stil.css">
</head>
<body>
    <header>
        <h1>Структурное программирование "Никлаус Вирт"</h1>
    </header>
    <nav>
        <ul>
            <li><a href="#examples">Биография Никлауса Вирта.</a></li>
            <li><a href="#overview">Общая информация о струткурном программировании.</a></li>
            <li><a href="#principles">Основные принципы структурного проекта.</a></li>
        </ul>
    </nav>
    <section id="overview">
        <h2>Биография Никлауса Вирта.</h2>
      <img src="https://images.app.goo.gl/A5KsuLsVSFmDQBHS6">
        <p>Родился Никлаус Вирт 28 февраля 1934 года в Цюрихе, Швейцария. Он проявил интерес к математике и физике в раннем возрасте, и эти увлечения стали основой его будущей карьеры. После окончания школы Вирт поступил в Цюрихский политехнический институт, где он изучал электротехнику. Вирт проявил особый интерес к компьютерам и программированию, и это стало его основной специализацией.</p>
        <p>Одним из важнейших достижений Никлауса Вирта стало создание структурного программирования. В конце 1960-х годов Вирт разработал концепцию структурного программирования, которая позволила упростить процесс создания программ и повысить их эффективность. Суть структурного программирования заключается в разделении программы на блоки или подпрограммы, которые могут быть использованы повторно. Это помогает улучшить понимание и поддержку кода, а также облегчает разработку сложных программных решений.</p>
        <p>Одним из ключевых достижений Никлауса Вирта в области структурного программирования было создание языка программирования Pascal. Этот язык программирования, впервые представленный в 1970 году, стал популярным инструментом для обучения программированию и разработки сложных программных систем. Pascal предоставил удобные инструменты для структурного программирования, включая блоки кода, условные операторы и циклы. Это позволило программистам лучше организовывать свой код и создавать более эффективные программы.</p>
     </section>
    <section id="principles">
        <h2>Общая ифнормация о структурном программировании.</h2>
        <p>Структурное программирование является фундаментальным подходом к разработке компьютерных программ, основным принципом которого является разбиение программы на небольшие, логически связанные блоки - подпрограммы, функции или процедуры. Оно помогает программистам создавать понятные, эффективные и поддерживаемые программы, путем применения определенных методологий и принципов.</p>
        <p>Одним из основных принципов структурного программирования является использование последовательной композиции блоков, то есть составление программы из последовательного выполнения упорядоченных операций. Это позволяет программисту легко отслеживать ход выполнения программы и выявлять возможные ошибки или проблемы.</p>
        <p>Другой важный принцип структурного программирования - это использование ветвлений и циклов. Ветвления позволяют программе принимать решения на основе определенных условий, в зависимости от которых выполнение программы может принимать различное направление. Циклы же позволяют программе выполнять определенные операции несколько раз, пока выполняется определенное условие.</p>
        <p>Помимо этих принципов, структурное программирование также подразумевает использование модульности, то есть разделение программы на отдельные модули или функции, каждая из которых отвечает за свою конкретную задачу. Это способствует повторному использованию кода, повышает его читаемость и делает программу более гибкой.</p>
    </section>
    <section id="examples">
        <h2>Принципы структурного программирования.</h2>
        <p>1. Любая программа представляет собой структуру, построенную из трёх типов базовых конструкций:</p>
        <p>•	последовательное исполнение — однократное выполнение операций в том порядке, в котором они записаны в тексте программы;</p>
      <img src=“https://images.app.goo.gl/saJQAARDjzGTLdro7”>
        <p>•	ветвление — однократное выполнение одной из двух или более операций, в зависимости от выполнения некоторого заданного условия;</p>
        <p>•	цикл — многократное исполнение одной и той же операции до тех пор, пока выполняется некоторое заданное условие (условие продолжения цикла).</p>
        <p>В программе базовые конструкции могут быть вложены друг в друга произвольным образом, но никаких других средств управления последовательностью выполнения операций не предусматривается.</p>
      <img src=“https://images.app.goo.gl/E65EqzoPo7RCVK4D7”>
        <p>2. Повторяющиеся фрагменты программы (либо не повторяющиеся, но представляющие собой логически целостные вычислительные блоки) могут оформляться в виде подпрограмм (процедур или функций). В этом случае в тексте основной программы, вместо помещённого в подпрограмму фрагмента, вставляется инструкция вызова подпрограммы. При выполнении такой инструкции выполняется вызванная подпрограмма, после чего исполнение программы продолжается с инструкции, следующей за командой вызова подпрограммы.</p>
      <p>Нисходящее проектирование</p>
        <p>Спецификация задачи служит отправной точкой в создании программы. Нужно понять, какие действия должны быть совершены для решения задачи, описать их на естественном языке и на достаточно высоком уровне абстракции.</p>
        <p>Спецификация задачи является ее первичным проектом. От неё мы движемся к программе, постепенно уточняя описание.</p>
        <p>Постепенное уточнение проекта называется методом проектирования сверху вниз (пошаговой детализации или нисходящего проектирования).</p>
        <p>Пример 1. В качестве примера рассмотрим проект одевания ребенка.</p>
      <p>Решение:</p>
<p>1. Первичная цель:</p>
<p>Одеть.</p>
<p>2. Конкретизация цели на первом шаге:</p>
<p>Одеть нижнюю половину.</p>
<p>Одеть верхнюю половину.</p>
<p>2.1. Нижнюю половину можно одеть в два этапа:</p>
<p>Надеть брюки. </p>
<p>Надеть носки и ботинки.</p>
<p>2.2. Верхнюю половину можно также одеть в два этапа:</p>
<p>Надеть рубашку.</p>
<p>Надеть куртку.</p>
<p>3. Окончательный проект выглядит так:</p>
<p>Надеть брюки. </p>
<p>Надеть носки.</p> 
<p>Надеть ботинки. </p>
<p>Надеть рубашку.</p>
        <p>Надеть куртку.</p>   
     <p>Метод нисходящего проектирования предполагает последовательное разложение общей функции обработки данных на простые функциональные элементы. В результате строится иерархическая схема – функциональная структура алгоритма (ФСА), отражающая состав и взаимоподчиненность отдельных функций </p>
      <p>Модульное программирование.</p>
      <p>Модуль – это самостоятельная часть программы, имеющая определенное назначение и обеспечивающая заданные функции обработки автономно от других программных модулей. Модуль состоит из логически взаимосвязанной совокупности функциональных элементов.</p>
<p>В программировании под модулем понимается отдельная подпрограмма, а подпрограммы часто называются процедурами или процедурами-функциями. Поэтому модульное программирование еще называется процедурным.</p>
<p>При создании программных продуктов выделяются многократно используемые модули, проводится их типизация и унификация, за счет чего сокращаются сроки и трудозатраты на разработку программного продукта в целом.</p>
<p>Некоторые программные продукты используют модули из готовых библиотек стандартных подпрограмм, процедур, функций, объектов, методов обработки данных.</p>
<p>Среди множества модулей различают: </p>
<p>•	головной модуль – управляет запуском программного продукта (существует в единственном числе); </p>
<p>•	управляющий модуль – обеспечивает вызов других модулей на обработку;</p> 
<p>•	рабочие модули – выполняют функции обработки; </p>
<p>•	сервисные модули и библиотеки, утилиты – реализуют обслуживающие функции.</p>
<p>В работе программного продукта активизируются необходимые программные модули. Управляющие модули задают последовательность вызова на выполнение очередного модуля. Информационная связь модулей обеспечивается за счет использования общей базы данных либо межмодульной передачи данных через переменные обмена.</p>
<p>Каждый модуль может оформляться как самостоятельно хранимый файл; для функционирования программного продукта необходимо наличие программных модулей в полном составе.</p>
<p>Модуль должен обладать следующими свойствами:</p>
<p>•	один вход и один выход – на входе программный модуль получает определенный набор исходных данных, выполняет содержательную обработку и возвращает один набор результатных данных, т.е. реализуется стандартный принцип IPO (Input–Process–Output – вход-процесс-выход); </p>
<p>•	функциональная завершенность – модуль выполняет перечень регламентированных операций для реализации каждой отдельной функции в полном составе, достаточных для завершения начатой обработки; </p>
<p>•	логическая независимость – результат работы программного модуля зависит только от исходных данных, но не зависит от работы других модулей; </p>
<p>•	слабые информационные связи с другими программными модулями – обмен информацией между модулями должен быть по возможности минимизирован; </p>
<p>•	обозримый по размеру и сложности программный код. </p>
<p>Модули содержат:</p>
<p>•	определение доступных для обработки данных;</p>
<p>•	операции обработки данных;</p>
<p>•	схемы взаимосвязи с другими модулями.</p>
<p>Каждый модуль состоит из спецификации и тела. Спецификации определяют правила использования модуля, а тело – способ реализации процесса обработки.</p>
<p>Однотипные функции реализуются одними и теми же модулями. Функция верхнего уровня обеспечивается главным модулем; он управляет выполнением нижестоящих функций, которым соответствуют подчиненные модули.</p>
<p>При определении набора модулей, реализующих функции конкретного алгоритма, необходимо учитывать следующее:</p>
<p>•	каждый модуль вызывается на выполнение вышестоящим модулем и, закончив работу, возвращает управление вызвавшему его модулю; </p>
<p>•	принятие основных решений в алгоритме выносится на максимально «высокий» по иерархии уровень; </p>
<p>•	для использования одной и той же функции в разных местах алгоритма создается один модуль, который вызывается на выполнение по мере необходимости. </p>
<p>В результате дальнейшей детализации алгоритма создается функционально-модульная схема (ФМС) алгоритма приложения, являющаяся основой для программирования. </p>
<p>Состав и вид программных модулей, их назначение и характер использования в программе в значительной степени определяются инструментальными средствами. </p>
      <img src=“https://images.app.goo.gl/wkF4ZmY5pT2VQtaR7”>
<p>Структурное кодирование.</p>
      <p>Структурное кодирование — это метод написания программ, имеющих определенную структуру и за счет этого удобных для понимания, тестирования, модификации и использования. </p>
<p>Данный метод основан на использовании небольшого набора простых управляющих структур (структурных операторов), правильность работы которых легко проанализировать и установить. При этом одни операторы состоят из других, вложенных в них.</p>
<p>Свойство структурности операторов состоит в том, что каждый оператор имеет один вход и один выход. Программа, построенная из структурных операторов, называется структурированной.</p>
<p>Теорема о структуировании устанавливает, что как бы сложна ни была задача, схему алгоритм ее решения (и, соответственно, программу) всегда можно представить в виде композиции трех типов вложенных блоков:</p>
<p>•	следования (begin-end – начало-конец),</p>
<p>•	ветвления (if-then-else – если-то-иначе),</p>
<p>•	циклов с предусловием (while – пока).</p>
<p>Другими словами, эти элементарные структуры обладают функциональной полнотой, т.е. любой алгоритм, может быть реализован в виде композиции этих трех структур.</p>
<p>На практике данная теорема позволяет избежать использования операторов перехода goto, что делает алгоритмы и программы наглядными и легко понимаемыми.</p>
      <p>1. Структура типа «следование» – образуется последовательностью действий, S1, S2, …, Sn, следующих одно за другим: </p>
<p>выполнить S1; </p>
<p>выполнить S2;</p>
<p>…</p>
<p>выполнить Sn.</p>
<p>В линейном вычислительном процессе все операции выполняются последовательно в порядке их записи. Типовым примером такого процесса является стандартная вычислительная схема, состоящая из трех этапов:</p>
<p>1)	ввод исходных данных;</p>
<p>2)	вычисление по формулам;</p>
<p>3)	вывод результата.</p>
  <p>В языке Pascal такая структура заключается в операторные скобки Begin ... End</p>
<p>2. Структура типа «ветвление» (ЕСЛИ – ТО – ИНАЧЕ) – обеспечивает в зависимости от результата проверки условия Р, принимающего одно из двух логических значении Да (True) или Нет (False), выбор одного из альтернативных путей работы алгоритма:</p>
<p>если Р</p>
 <p>  то выполнить S1</p>
   <p>иначе выполнить S2.</p>
     <p>Каждый из путей ведет к общему выходу, так что работа алгоритма будет продолжаться независимо от того, какой путь будет выбран.</p>
<p>В языке Pascal такая структура имеет следующий формат:</p>
 <p> 3. Структура типа «цикл с предусловием»  – обеспечивает многократное выполнение действия S в зависимости от того, какое значение принимает логическое условие Р:</p>
<p>до тех пор пока Р </p>
 <p>  выполнять S.</p>
<p>Выполнение цикла прекращается, когда условие Р не выполняется.</p>
<p>В языке Pascal такая структура имеет следующий формат:</p>
<p>В расширенный комплект элементарных алгоритмических структур дополнительно входят следующие управляющие конструкции </p>
      <img src=“https://images.app.goo.gl/wjU71mTC9v5rgSGW8”>
<p>4. Структура типа «сокращенное ветвление» (ЕСЛИ – ТО) – если результат проверки условия Р принимает значение Да (True), то выполняется действие S; в противном случае это действие пропускается и управление передается следующей структуре: </p>
<p>если Р</p>
   <p>то выполнить S1.</p>
<p>В языке Pascal такая структура имеет следующий формат:</p>
<p>5. Структура типа «выбор – иначе» являются расширенным вариантом структуры типа ЕСЛИ – ТО – ИНАЧЕ. Здесь проверяемое условие Р может принимать не два логических значения, а несколько порядковых значений, например, 1, 2, …, n. Если Р = i, то будет выполняться действие Si. Если же значение Р будет выходить из диапазона допустимых значений, то выполняется действие S (в укороченном варианте «выбор» никакого действия не производится и управление передается к следующей структуре. В языке Pascal такая структура имеет следующий формат:</p>
 <p>6. Структура типа «цикл с постусловием»  – обеспечивает многократное выполнение действия S до тех пор, пока не выполняется условие Р.</p>
<p>В языке Pascal такая структура имеет следующий формат:</p>
<p>7. Структура типа «цикл с параметром»  – обеспечивает заранее определенное многократное выполнение действия S. При этом здесь последовательно выполняются следующие типовые операции:</p>
<p>•	задание начального значения используемого параметра цикла (например, если переменной цикла является i, то ей присваивается значение i1, т.е. i:=i1);</p>
<p>•	выполнение действий S, предусмотренных в теле цикла;</p>
<p>•	изменение параметра цикла, который обеспечивает вычисление результата с новыми начальными данными (например, если параметр цикла i изменяется с шагом i3, i:=i i3);</p>
<p>•	проверка текущего значения параметра цикла с заданным конечным значением (i<=i2);</p>
<p>•	переход к повторению тела цикла, если параметр цикла не превысил конечного значения, иначе — выполнение следующих действий или вывод результата.</p>
<p>В языке Pascal такая структура имеет следующий формат:</p>
<p>Рассматривая схему программы, можно выделить в ней части (фрагменты), достаточно простые и понятные по структуре. Представление этих фрагментов укрупненными блоками существенно облегчает восприятие алгоритма (а в дальнейшем и программы) в целом.</p>
<p>Структурные операторы обычно применяются уже на ранних стадиях нисходящего проектирования программы.</p>
<p>Таким образом, структурное программирование основано на модульной структуре программного продукта и типовых (базовых) управляющих структурах алгоритмов обработки данных различных программных модулей.</p>
    </section>
  <script src="as.js"> </script>
</body>
</html>